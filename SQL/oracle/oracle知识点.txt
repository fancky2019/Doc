
-- 创建序列
CREATE SEQUENCE mq_fail_log_seq
INCREMENT BY 1
START WITH 1
NOMAXvalue
NOCYCLE;

-- 查看序列
select SEQUENCE_OWNER,SEQUENCE_NAME from dba_sequences where sequence_owner='用户名';

select SEQUENCE_OWNER,SEQUENCE_NAME from dba_sequences where sequence_owner='sys';

select * from dba_sequences

-- 日期
update t_gx_share_list set GX_EFFECT_FIRST_TIME= to_date ( '2022-08-16 10:54:02' , 'YYYY-MM-DD HH24:MI:SS' ) ;


--分页

-- 40为pageCurrent * pageSize，30 应为为(pageCurrent - 1) * pageSize
-- 由于oracle排序算法问题，如果排序遇到相同的条件，比如时间，会使分页后一页包含前一页的内容，所以这个时候要把方法改成下面这两种。

select  *  from mq_fail_log;

-- 方法一，order by 加上id主键
SELECT * FROM  
(  
    SELECT A.*, ROWNUM RN 
    FROM (
        SELECT * FROM mq_fail_log 
        WHERE 1 = 1 
        ORDER BY CREATE_TIME DESC,id
        ) A  
 )B
WHERE RN>3 AND RN<=6
 --WHERE RN BETWEEN 4 AND 6

-- ROW_NUMBER() OVER(order by id) 
SELECT * FROM  
(  
    SELECT A.*, ROW_NUMBER() OVER(order by id) RN
    FROM (
        SELECT * FROM mq_fail_log 
        WHERE 1 = 1 
        ORDER BY CREATE_TIME DESC
        ) A  
 )B
WHERE RN>3 AND RN<=6

-- 性能好点
-- 注意：内层用的是ROWNUM<=6 不是别名RN，也不能用ROWNUM>3 AND ROWNUM<=6否则查不出数据
SELECT * FROM  
(  
    SELECT A.*, ROWNUM RN 
    FROM (
        SELECT * FROM mq_fail_log 
        WHERE 1 = 1 
        ORDER BY CREATE_TIME DESC,id
        ) A  
    where  ROWNUM<=6
 )B
WHERE RN>3 









-- like      and t.name LIKE concat(CONCAT('%',#{uniInsuranceName}),'%')
       
--   and t.cust_name like ('%' || #{gxBizRequest.custName} || '%')


-- 获取所有用户的表
select table_name from all_tables;
-- 获取当前用户的表
select table_name from user_tables;
-- 获取所有表（包括系统表）
select table_name from dba_tables;
-- 获取指定用户下的所有表
select table from dba_tables where owner = 'xxx';



SELECT 
  a.OWNER 模式,
  a.TABLE_NAME 表名, 
  a.COLUMN_NAME 列名, 
  a.DATA_TYPE 数据类型, 
  a.DATA_LENGTH 长度, 
  a.NULLABLE 非空, 
  --(CASE WHEN a.NULLABLE = 'N' THEN 'Y' ELSE 'N' END) 非空,
  b.COMMENTS 注释
FROM all_tab_columns a
LEFT JOIN all_col_comments b ON a.OWNER = b.OWNER AND a.TABLE_NAME = b.TABLE_NAME AND a.COLUMN_NAME = b.COLUMN_NAME
WHERE a.OWNER = 'sys' AND a.TABLE_NAME = 'TABLE_NAME '
ORDER BY a.TABLE_NAME, a.COLUMN_ID

--或者

SELECT 
  a.TABLE_NAME 表名, 
  c.COMMENTS 表名称,
  a.COLUMN_NAME 列名, 
  a.DATA_TYPE 数据类型, 
  a.DATA_LENGTH 长度, 
  a.NULLABLE 非空, 
  --(CASE WHEN a.NULLABLE = 'N' THEN 'Y' ELSE 'N' END) 非空,
  b.COMMENTS 列注释
FROM user_tab_columns a
LEFT JOIN user_col_comments b ON a.TABLE_NAME = b.TABLE_NAME AND a.COLUMN_NAME = b.COLUMN_NAME
left join user_tab_comments c on a.TABLE_NAME=c.TABLE_NAME
WHERE 1=1
--  and  a.TABLE_NAME = 'TABLE_NAME '
ORDER BY a.TABLE_NAME




#查看表名称注释
SELECT * FROM user_tab_comments WHERE TABLE_NAME='CODE_GENERAL'

select * from user_col_comments
where TABLE_NAME not in (select TABLE_NAME from user_tab_columns)
      or COLUMN_NAME not in (select COLUMN_NAME from user_tab_columns)


-- 插入指定序列
CREATE SEQUENCE RULE_FACTOR_SEQ
INCREMENT BY 1
START WITH 1
NOMAXvalue
NOCYCLE;

INSERT INTO "RULE_FACTOR"("ID", "RULE_ID", "FACTOR_NAME", "FACTOR", "CONDITION", "CONDITION_VALUE") 
VALUES(RULE_FACTOR_SEQ.nextval , 1,'分公','company','like','上海'),

(RULE_FACTOR_SEQ.nextval , 2,'使用性质','property','in','1,23,3'),
(RULE_FACTOR_SEQ.nextval , 3,'在保车辆','cars','=','1'),
(RULE_FACTOR_SEQ.nextval , 4,'上一年签单保费规模','fee','between','[100,400]');

-- 行转列

SELECT RULE_ID,
MAX(CASE  WHEN FACTOR_NAME ='分公' THEN CONDITION_VALUE END) AS 分公,
MAX(CASE  WHEN FACTOR_NAME ='使用性质' THEN CONDITION_VALUE END )AS 使用性质,
MAX(CASE  WHEN FACTOR_NAME ='在保车辆' THEN CONDITION_VALUE END) AS 在保车辆,
MAX(CASE  WHEN FACTOR_NAME ='上一年签单保费规模' THEN CONDITION_VALUE END) AS 上一年签单保费规模
FROM RULE_FACTOR WHERE FACTOR_NAME IN('分公' ,'使用性质' ,'在保车辆' ,'上一年签单保费规模')
GROUP BY RULE_ID;


SELECT * FROM (
    SELECT RULE_ID,FACTOR_NAME,CONDITION_VALUE FROM  RULE_FACTOR
    ) t
PIVOT( 
      max(CONDITION_VALUE) FOR FACTOR_NAME 
      IN (
          '分公' as 分工 ,
          '使用性质' as 使用性质,
          '在保车辆' as 在保车辆,
          '上一年签单保费规模' as上一年签单保费规模)
    );
	
	
-- 行转多列	
SELECT RULE_ID,
MAX(CASE  WHEN FACTOR_NAME ='分公' THEN CONDITION_VALUE END) AS company,
MAX(CASE  WHEN FACTOR_NAME ='使用性质' THEN CONDITION_VALUE END )AS property,
MAX(CASE  WHEN FACTOR_NAME ='在保车辆' THEN CONDITION_VALUE END) AS cars,
MAX(CASE  WHEN FACTOR_NAME ='上一年签单保费规模' THEN CONDITION_VALUE END) AS fee,

MAX(CASE  WHEN FACTOR_NAME ='分公' THEN FACTOR END) AS company_FACTOR,
MAX(CASE  WHEN FACTOR_NAME ='使用性质' THEN FACTOR END )AS property_FACTOR,
MAX(CASE  WHEN FACTOR_NAME ='在保车辆' THEN FACTOR END) AS cars_FACTOR,
MAX(CASE  WHEN FACTOR_NAME ='上一年签单保费规模' THEN FACTOR END) AS fee_FACTOR,

MAX(CASE  WHEN FACTOR_NAME ='分公' THEN CONDITION END) AS company_CONDITION,
MAX(CASE  WHEN FACTOR_NAME ='使用性质' THEN CONDITION END )AS property_CONDITION,
MAX(CASE  WHEN FACTOR_NAME ='在保车辆' THEN CONDITION END) AS cars_CONDITION,
MAX(CASE  WHEN FACTOR_NAME ='上一年签单保费规模' THEN CONDITION END) AS fee_CONDITION

FROM RULE_FACTOR WHERE FACTOR_NAME IN('分公' ,'使用性质' ,'在保车辆' ,'上一年签单保费规模')
GROUP BY RULE_ID;
	
	
	
	
	
	
	
	
	
	
	