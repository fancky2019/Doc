input {
    jdbc {
	    # 8.0以上版本：一定要把serverTimezone=UTC天加上
        jdbc_connection_string => "jdbc:mysql://localhost:3306/demo?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=UTC"
        jdbc_user => "root"
        jdbc_password => "123456"
        jdbc_driver_library => "D:\work\software\es\mysql-connector-java\mysql-connector-java-8.0.26.jar"
        jdbc_driver_class => "com.mysql.jdbc.Driver"
        jdbc_paging_enabled => "true"
        jdbc_page_size => "10000"
        # 脚本执行路径,在sync目录中配置，注意里面的条件updated_at := sql_last_value
        #statement_filepath => "D:\work\software\es\logstash-8.0.1\sync\person.sql"
		#tracking_column 必须在查询的列中。如update_time
		statement => "select  id,`name`,age,update_time   from person where update_time >= :sql_last_value ;"
		#5秒同步一次，默认一分钟同步一次 schedule => "* * * * *"
        schedule => "*/5 * * * * *"
        # 索引类，多表同步时，表类型区分，建议命名为“库名_表名”，每个jdbc模块需对应一个type；
        #type => "_doc"
		type => "demo_person"
        # 开启记录追踪，上次执行的时间，这个记录会保存到下面指定的文件中去
        use_column_value => true
        #记录最后一次:sql_last_value的时间
        last_run_metadata_path => "D:\work\software\es\logstash-8.0.1\sync\time.log"
        #跟踪的列update_time
        tracking_column => "update_time"
		#update_time的类型
        tracking_column_type => "timestamp"
        #是否清除 last_run_metadata_path 中的内容，不需要清空
        clean_run => false
        lowercase_column_names => false
    }
}

filter {
#
#     # 把东八区时间赋值给@timestamp字段
#     ruby {
#         code => "event.set('timestamp', event.get('@timestamp').time.localtime + 8*60*60)"
#     }
#     ruby {
#          code => "event.set('@timestamp',event.get('timestamp'))"
#     }

}

output {
    elasticsearch {
        #集群配置，ES8使用SSL。hosts => ["192.168.1.1:9200", "192.168.1.2:9200", "192.168.1.3:9200"]
        hosts => ["192.168.125.166:9200"]
		#ES8 设置了用户名密码和证书
		ssl => true
		user => "elastic"
        password => "2yaE2Ye9*abw=WfUoTHx"
		cacert => "D:\work\software\es\logstash-8.0.1\data\cert\cert.crt"
        # 索引名称
        index => "person"
        # 设置document 的id和数据的id一致
        document_id => "%{id}"
		manage_template => false
    }
    stdout {
        codec => json_lines
    }
}
